TODO:
* modules
   * sourceFile will need to compile functions just in the current file. It currently compiles ALL functions
     we've ever added.

   * function names etc, will have to be prefaced by their file name. actually, even file name
     isnt totally unique, so some sort of unique name will have to be generated.
   * for things like "import "fs"", will have to generate a wrapper output file
     which appropriately hooks stuff up.
   * going to need to make relative and absolute paths the same and parse out any redundant paths.

* Fat arrow / function / method declarations share a lot of common code.
* Remove Sx
* functions and fat arrows are not compiling BSBlocks correctly. They should just .compile() the block rather than doing...the...thing.
* call expression double evaluates a in a.b();. Should probably ensure that this doesn't cause any issues
  or, more ideally, just cache it...
* unify the 3 separate methods for compiling functions - and probably name them something else other than compile().
* functions should pass in Function into S.Func
   * They should also pass in the appropriate (wasm) return value
* add strings with +
* print arrays correctly (log pls)
* i think there may be a large bug with strings where i always write mem in 4 byte chunks, meaning writing at the final char would overwrite the
  next thing in memory.
* cant have two for loops in scope with the same name lol. i think the i should be scoped INSIDE the for loop ??????
   * come to think of it, even if has its own scope.
* merge the logic in callexpression to get the function type name with the logic in function to create a function type name.
* proprety and function look up e.g. in properties.ts should be done by a class key rather than a filter.
* need some sort of debug flag to keep debug information
   * position in stack
   * names of functions (or even variables).
* have some sort of sexpr option for newlines at end of sexprs.
* Sexprs can be better created if i use some sort of function overloading syntax such that S("add") automagically
  figures out the right arguments (and return type!).
* log:
  * pull line number ha! This is not even that hard!
  * get correct file name.
* i should handle functions returning void rather than just saying everything returns an i32 lol (in functions.ts)
* move everything in functions towards getting functions by identifier
* looks liek we're generating string_temp when we shouldnt be
* callexpression ALWAYS uses the function table. however it's pretty easy not to when we have identifiers.
* should work out what left hand side expression is. see: decorator.ts
* Remove the string-specific array handling in elementaccess.ts
* BuiltInArrays need to be generic.
  * elementAccess needs to calculate the element size offset propertly rather than defaulting to 4.
* rename ctx to environment (or env i guess.)
* better error handling
* type parameters are hard - i have to generate the same code for each thing they could plausibly be.
* offset() could also indicate arrays.
* the initial pass to add functions to the file is now entirely unnecessary
* Figure out some way to write Sexprs better.
* vscode integration
* figure out a way to inline constructors
   * I'm beginning to have a good idea of how to do this. The only "hard" part is parsing the string/array literal. the
   rest i can write code for. So I should just have a couple of builtins for the literals, and then use a constructor like
   normal.
* THOUGHT: should Sexpr be Sexpr<T> where T is the type? I feel like it could be?
* put getExpressionNode on BaseNode
   cant be done, circular dependencies.
* add imports so that my code isnt such a mess
  * http://fredkschott.com/post/2014/06/require-and-the-module-system/
* remove all !
* rename parseStatementListBS
* for special functions (like log), we should ensure you actually imported them from somewhere,
  otherwise you dont get them.
* assertEquals() rather than just returning true from inside code blocks
* eventually eradicate all getText()
* hard stuff
  * closures
  * generics (is there a better way than just copy pasting the asm implementation n times for n call sites)
* rewrite log to use malloc so its not a ticking time bomb!!!!!!! it was overwriting my malloc offset and causing everything to explode.
   * okay so the main thing is that log is polymorphic on argument type, but that's impossible to currently do rn because
   all values are the same and have no type information. HOWEVER, it's not impossible in theory because i could write
   static functions to... wait no, yeah, it's impossible. lol.
* use data segment
* define lib.d.ts for bs
  * ok... bs is a pretty bad acronym...
X add simple memory allocator
  * string allocations need to be declared up front
  * all temporary variables need to know their type (string, object, etc etc etc)
  * each block should have a way to declare ahead of time what local variable names its going to need
    * actually i think a better way would be to request a NUMBER of local variables, so that we can continue to
      use from the same pile rather than having a ton of unnecessary ones.
* which gets added to every program
* figure out how to do simple dispatches on strings, like length
* generate straight wasm rather than wat

* fun optimization ideas:
  * pull out constant expressions that are repeatedly evaluated
  * inline functions

TODO: generate a d.ts file for the exported members of the wasm thing
TODO: actually check for TS errors n stuff.


useful to get wat snippets
https://mbebenita.github.io/WasmExplorer/
https://blog.scottlogic.com/2018/05/29/transpiling-webassembly.html

JS unit tests as far as the eye can see.
https://github.com/v8/v8/tree/master/test/mjsunit
